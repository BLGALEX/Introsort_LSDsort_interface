#pragma once



// Лепёха А.А. Б8118-09.03.04прогин(2)

/**
 * Данная вариация интроспективной сортировки работяет для любых типов
 * для которых определны операции стравнения
 *
 */

 /**
  * Входные данные: два указателя на ячейки памяти
  *
  * Выходные данные: две ячейки памяти
  *
  * Меняет местами данные, хранящиеся в двух ячейках памяти
  *
  * @param *a - указатель на ячейку памяти
  * @param *b - указатель на ячейку памяти
  */
template<class T>
void swap(T* a, T* b)
{
	T temp = a[0];
	a[0] = b[0];
	b[0] = temp;
}

/**
 * Входные данные: указатель на первый элемент участка массива и указатель на последний элемент участка миссива
 *
 * Выходные данные: часть массива приведённая к куче, где внизу самые большие числа
 *
 * Функция начиная от n/2-1 элемента начинает "просеивать" их через дерео, чтобы получить дерево сортировки
 *
 * @param *left - указатель на первый элемент участка массива
 * @param *right - указатель на последний элемент участка массива
 */
template<class T>
void HeapSetUp(T* left, T* right) // приводим к куче, чтобы a[i] <= a[2*i+1] && a[i] <=a[i*2+2]
{
	int n = (((int)right - (int)left) / sizeof(T)) + 1;
	for (int i = n / 2 - 1; i >= 0; i--) // начинаем просеивать с n/2-1 элемента
	{
		for (int j = i; j <= n / 2 - 1; )
		{
			if ((j * 2 + 2) > (n - 1))
			{
				if (left[j * 2 + 1] < left[j])
				{
					swap(&left[j * 2 + 1], &left[j]);
					j = j * 2 + 1;
				}
				else break;
			}
			else if (left[j * 2 + 1] < left[j * 2 + 2] && (left[j * 2 + 1] < left[j]))
			{
				swap(&left[j * 2 + 1], &left[j]);
				j = j * 2 + 1;
			}
			else if (left[j * 2 + 2] < left[j])
			{
				swap(&left[j * 2 + 2], &left[j]);
				j = j * 2 + 2;
			}
			else break;
		}
	}
}

/**
 * Входные данные: указатель на первый элемент участка массива и указатель на последний элемент участка миссива
 *
 * Выходные данные: отсортированная часть массива
 *
 * Функция меняет местами 1 и последний элемент текущего дерева и "просеивает" новую вершину через дерево,
 * размер которого уменьшается на один (то есть правая граница массива смещается на единицу влево).
 * Это проделываем до тех пор, пока масив не будет состоять из одного элемента
 *
 * @param *left - указатель на первый элемент участка массива
 * @param *right - указатель на последний элемент участка массива
 */
template<class T>
void HeapSort(T* left, T* right)
{
	HeapSetUp(left, right);// сначала приводим к куче, где большие элементы внизу
	int n = ((int)right - (int)left) / sizeof(T) + 1;
	for (int i = n; i > 0; i--)//после каждой итерации дерево становится отсортированным с конца на ещё на один элемент
		//поэтому мы работаем каждый раз с деревом меньшим на 1 элемент с конца
	{
		swap(&left[0], &left[i - 1]); // ставим наименьший элемент текущего дерева в конец и элемент с конца просеиваем через всё оставшееся дерево
		for (int j = 0; j < (i + 1) / 2 - 1; )
		{
			if ((j * 2 + 2) >= (i - 1))
			{
				if (left[j * 2 + 1] < left[j])
				{
					swap(&left[j * 2 + 1], &left[j]);
					j = j * 2 + 1;
				}
				else break;
			}
			else if (left[j * 2 + 1] < left[j * 2 + 2] && (left[j * 2 + 1] < left[j]))
			{
				swap(&left[j * 2 + 1], &left[j]);
				j = j * 2 + 1;
			}
			else if (left[j * 2 + 2] < left[j])
			{
				swap(&left[j * 2 + 2], &left[j]);
				j = j * 2 + 2;
			}
			else break;
		}
	}
	for (int i = 0; i < n / 2; i++) //выписываем дерево с конца
		swap(&left[i], &left[n - i - 1]);
}

/**
 * Входные данные: указатель на начало массива и номер элемента с которого нужно сортровать и номер элемнта до которого нужно сортировать
 * А также кольчество элементов массива при первом вызове функции и глубина рекурсии
 *
 * Выходные данные: отсортированныя часть массива
 *
 * Функция в завиимости от глубины рекурсии сортирует участок массива быстрой сортировкой и вызывает сама себя, если требуется
 * или сортирует участок массива пирамидальной сортировкой с помощью вызова соответствующей процедуры
 *
 * @param *arr - указатель на ячейку памяти
 * @param left - номер первого элемента массива в памяти
 * @param right - номер последнего элемента массива в памяти
 * @param actuall_len - изначальное количество элементов массива
 * @param deep - глубина рекурсии (изначально == 1)
 */
template <class T>
void realIntrosort(T* arr, int left, int right, int actuall_len, int deep)
{
	if (log(actuall_len) < deep)
	{
		HeapSort(arr + left, arr + right);
	}
	else
	{
		T pivot; // разрешающий элемент
		int l_hold = left; //левая граница
		int r_hold = right; // правая граница
		pivot = arr[left];
		while (left < right) // пока границы не сомкнутся
		{
			while ((arr[right] >= pivot) && (left < right))
				right--; // сдвигаем правую границу пока элемент [right] больше [pivot]
			if (left != right) // если границы не сомкнулись
			{
				arr[left] = arr[right]; // перемещаем элемент [right] на место разрешающего
				left++; // сдвигаем левую границу вправо
			}
			while ((arr[left] <= pivot) && (left < right))
				left++; // сдвигаем левую границу пока элемент [left] меньше [pivot]
			if (left != right) // если границы не сомкнулись
			{
				arr[right] = arr[left]; // перемещаем элемент [left] на место [right]
				right--; // сдвигаем правую границу вправо
			}
		}
		arr[left] = pivot; // ставим разрешающий элемент на место
		int piv = left;
		left = l_hold;
		right = r_hold;
		deep++;
		if (left < piv) // Рекурсивно вызываем сортировку для левой и правой части массива
			realIntrosort(arr, left, piv - 1, actuall_len, deep);
		if (right > piv)
			realIntrosort(arr, piv + 1, right, actuall_len, deep);

	}
}

/**
 * Входные данные: указатель на начало массива и размер данного массива
 *
 * Выходные данные: отсортированный массив
 *
 * Функция считает сколько элементов в области массива и вызывает другую функцию, которая уже выполняет сортировку
 *
 * @param *arr - указатель на ячейку памяти
 * @param n - количество элементов в массиве
 */
template<class T>
void Introsort(T* arr, int n)
{
	realIntrosort(arr, 0, n - 1, n, 1);
}
